% PacBio Assembly
% Ming Chen (mchen@cs.stonybrook.edu), 108319345 \
 Yunting Xia (yunting.xia@gmail.com), 108269572 \
 Xiaoshuai Yuan (joannaysx@hotmail.com), 106166174
% 2011-12-08 

# 1. Introduction
Most shotgun sequencing methods use huge amount of short fragments to assemble
the whole DNA sequence. However, new sequencing instruments from Pacific
Biosciences can sequence much longer fragments of DNA than any other sequencing
technology over 2000bp compared to 100-500bp, but at a much higher error rate
(typically 15% error). The long read length makes the instruments very
attractive for de novo assembly of complex genomes, but the high error rate
prevents traditional approaches from being used. Nevertheless, with high
coverage, it is still possible to eliminate the read errors and assembling the
whole genome from them.

Our team aims at assembling the genome of E-coli from PacBio's long sequence
reads with high error rate. Researcher in PacBio eliminated the errors by
aligning relatively short but accurate Circular Consensus Sequencing (CCS) reads
against those long reads. However, we proposed to assemble the genome using
only long reads, which is challenging but possible thanks to large coverage of
the reads. 

The key issue of our problem is to efficiently and accurately detect overlaps.
Our approach employs the seed-and-extend paradigm, in which spaced seed is used
to sufficiently locate possibly overlapped sequences. Sequence aligner is then
applied to those candidates to work out possible alignment. Once aligned, more
precise sequence can be obtained by consensus. 

# 2. Algorithm

# 2.1. Seed-and-extend
Our algorithm iteratively aligns long reads to a reference, which represents all
sequences already aligned. During each alignment, the aligned reads will vote to
correct errors in the reference and expand it if they are at boundaries of the
reference. Eventually, the reference will be the genome or contigs we are
looking for. It is important to maintain the reference as accurate as possible,
so that minimum structural errors will be introduced in the grow process. To
guarantee this, the reference should start as an accurate sequence. There are
several methods to get an initial high quality reference. One is to select those
long reads with high average Phred quality scores, which are easily accessible
in the FASTQ sequence files downloaded from DevNet of PacBio. Another method is
to use a CCS read, which is inherently of high accuracy. According to the data
provided by PacBio, the mean accuracy of CCS read is 97.8. 

During the extend process, it is most important that the extension comes from a
really overlapped sequence. Otherwise, there will be structural errors in the
reference, which will cause a wrong assembly or early failure of iteration. 

## 2.2. Overlap detection

Spaced seeds are used to find overlapped sequence that can be aligned to the
reference. To achieve this, we build a seedmap for the reference and detect
overlaps by looking up seeds from a candidate read into it. The seedmap is a
hashmap for all possible seeds of the reference, so look-up into it is fast.
Given a reference of length $n$ and a spaced seed with length $k$ and weight $w$
(weight here is the number of 1s in the spaced seed pattern, e.g., the weight of
 the 16-base-long seed pattern `111*11*1*1*1*111` is 11), there will be $n-k+1$
seeds, when the seed pattern is applied to the reference at different places.
For each candidate read, there is no need to lookup all of its seeds because we
can safely rule it out if it fails a certain number of trials. The trial of
alignment always starts at one end of the sequence. So it is enough to only look
at seeds at both ends. 

If there is a match of seed, there will an attempt to align the sequence against
the reference. The alignment basically calculates the shortest edit distance,
    which is dynamic programming process with square order of complexity.
    However, because we are only interested in those sequence with high
    similarity. It is not neccessary to go through all elements in the DP
    matrix. Only the diagonal region of the matrix will be used and updated.
    The average of error rate is 15%, so the mutual difference will be around
    30%. The time and space of the alignment will be $0.3n^2$. Because most
    sequences are about 3000-base-long, the complexity of a typical successful
    alignment is around 900000. This is affordable on a modern computer. 

It is desirable that the overlaps happen at the boundaries of the reference.
Because the reference can grow and the iteration will converge quickly. However,
we should be careful since the length of overlapped region can be small. But
overlap of a short region can happen frequently by accident. To avoid this
situation, the alignment must be significant long to justify the overlap. 

## Tradeoffs
In our algorithm, several tradeoffs have been made to balance between accuracy
and speed. Firstly, in the dynamic programming process, it is reasonable to quit
and report failure if intermidate optimal distance becomes significantly large.
This early failure strategy will miss some overlaps with low match in the prefix
but high match as a whole, however, it will considerably accelerate the
alignment. 

To converge quickly, it is absolutely favorable to detect all possible overlaps
during each iteration. However, this is quite difficult considering the high error
rate. Otherwise, the program when greatly slows down when the reference becomes
long. If all seeds in the long reference are placed into the seedmap, the
probability of accident seed-matches will increase dramastically. Actually, our
algorithm aims at correcting errors and assembling sequences at the same time.
However, preference over assembling sequences is desirable at the early stage.
As long as we can grow the reference and obtain a rough overview structure, we
can correct the errors thereafter. To the opposite, if the reference cannot grow
smoothly, the iteration will fail at an early stage. We note that only overlaps
at boundaries are helpful for reference grow, we will only build seedmap for
both ends of the reference in the seedmap before the length of reference
approach the length of the genome. Therefore, the number of seed-matches will be
limited and the iteration period get shortened.

# 3. Implementation
We have implemented the algorithm using C++. It is public available at
https://github.com/brianchenming/PacBioAssembly. The long reads are "E. coli
C227-11 Filtered Reads FASTQ" from
http://www.pacbiodevnet.com/Share/Datasets/E-coli-Outbreak. The sequence files
are 3G after decompression and DNA sequences contribute half of the size,
    whereas the other half is quality string in the FASTQ format. But, 1.5G is
    still quite large and cannot fit into our laptop's memory. However, we do
    not want to do too much disk IO becomes IO operations can significantly slow
    down the whole program. So we converted the DNA sequences into a binary file
    and decrease the memory assumption into a quarter of the size. The binary
    format is not only memory efficient, it also facilitates the calculation of
    spaced seeds. By carefully choosing the seed pattern to be of length 16, a
    seed can fit into one 32-bit (2 bits for one base) machine word, so a seed
    match is just a comparison of two unsigned integers. Using binary format, we
    can easy obtain seeds using bitwise operations on the sequence and the seed
    pattern. A class is created to provide interfaces of manipulating the binary
    format. 

## Seedmap
The seedmap is implemented as a hash_map from the standard template library.
Ideally, every time the reference gets updated by incorporating a new read, its
seedmap should be refreshed as well. But it is very time-consuming, especially
when it becomes long in the late phases of the iteration. So, we made a tradeoff
and only add elements into the seedmap in one iteration. First, let us consider
the case of substitution. A 'C' base at the $j$-th position of the reference may
have been voted to become 'G'. In our implementation, this change of consensus
will not be reflected in the seedmap until next iteration. This delay of update
is not a big problem because missed overlaps can be detected in later
iterations. Second, as to deletion, we can just ignore it because a deletion of
a base it is just an absence of one vote at that position. We can delete the
base if it gets significant less votes at the end of iteration. The third case,
     insertion, is the most difficult. For insertion at the two ends of the
     reference, it is easy because we can add new seed without invalidating the
     seedmap. It is difficult to handle insertion in the middle while keeps
     elements in the seedmap intact. In our implementation, we solved this by
     only allowing one insertion after each place. Alignments with overlaps may
     insert many bases after one position, however, no matter how many bases are
     inserted by whatever-number-of-overlaps, only one box is used for all of
     them. For example, one read wants to insert 'ACCG' after the $j$-th
     position of the reference, and another read wants to insert 'GGT' at the
     same position, then the box reserved for insertion at that position will
     have votes 'A:1, C:2, G:3, T:1'. If 3 is significant, there will be one
     additional 'G' only after the current round terminates. The code for the
     overlaps detection is finished and partially tested, while the code for
     updating seedmap after alignment is drawing to an end. 

## Program structure
Besides seedmap, there are seven core classes as presented in Figure 1. *dna_seq*
is an abstration of DNA sequence and *seq_accessor* capsulate the method to visit
*dna_seq*. *seq_aligner* is the class responsible for aligning two sequences.
ref_seq represents the reference it is also the place where *vote_box* resides.
*vote_box* is composed of two *base_vote*, one being selection and other being
suppliment. 

## Test
Using GoogleTest, we have created comprehensive unit test cases for these
classes. The binary format has also being tested on real data. We successfully
converted 100M sequence into binary file and get the exact sequences back in
text format. For the alignment, a *visual_align* has been implemented to
visualize alignment for maually check. During the iteration, there is summary
information for every alignment including the edit distance and the length of
match in both reference and sequence. Therefore, we can check the output and
make sure the alignment are working properly. Moreover, an option has been
provided in our program to dump all aligned sequence during the whole process. 

# 3. Experiment
## 3.1. Overlap detection
## 3.2. Experiment on corrected reads
## 3.3. Experiment on error reads

# 4. Future work

# 4. Conclusion
We have studied two possible methods to use the long fragments for DNA assembly.
The key point for both methods is to eliminate errors using consensus of
overlapped fragments. Thanks to the high coverage, it is likely that most errors
will be corrected. As long as fragments overlaps can be detected efficiently, the
assembly of corrected long fragments should be relatively easy. 

# References

[Altschul 1990] S. F. Altschul, W. Gish, W. Miller, E. Myers, D. J. Lipman,
    Basic local alignment search tool, J. Mol. Biol., 215 (1990), 403-410.

[Ma 2002] B. Ma, J. Tromp, M. Li, Pattern Hunter–faster and more sensitive
homology search. Bioinformatics, 18 (2002), 440-445.

[Keich 2004] U. Keich, B. Ma, M. Li, and J. Tromp, On spaced seeds for
similarity search, Discrete Applied Mathematics 138 (3) (2004), 253–263.

[Choi 2003] K. Choi, F. Zeng, and L. Zhang, Good spaced seeds for homology
search.  Bioinformatics 20 (2003), 1053-1056.

[Ukkonen 1985] E. Ukkonen, Algorithms For Approximate String Matching,
    Information and Control, 64 (1985), 100-118. 

[Roover 2005] C. De Roover, C. De Vleeschouwer, F. Lefebvre, B. Macq, Robust
video hashing based on radial projections of key frames, IEEE Transactions on
Signal Processing, 53 (10), 2005, 4020-4037. 

[Pevzner 2001] P. A. Pevzner, H. Tang, and M. S. Waterman. 2001, A New Approach
to Fragment Assembly in DNA Sequencing, Proceedings of the Fifth Annual
International Conference on Computational Biology (RECOMB '01), New York, NY,
              256-267.
